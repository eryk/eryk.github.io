<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuqi365.com","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Python量化交易实战">
<meta property="og:url" content="http://xuqi365.com/index.html">
<meta property="og:site_name" content="Python量化交易实战">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="eryk">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xuqi365.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Python量化交易实战</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Python量化交易实战" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Python量化交易实战</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/12/20/2020-12-20%20%E6%8A%95%E8%B5%84%E8%91%97%E4%BD%9C%E5%93%81%E8%AF%BB1%EF%BC%9A%E3%80%8A%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9FII:%E5%8D%96%E5%87%BA%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%8D%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/20/2020-12-20%20%E6%8A%95%E8%B5%84%E8%91%97%E4%BD%9C%E5%93%81%E8%AF%BB1%EF%BC%9A%E3%80%8A%E4%BB%A5%E4%BA%A4%E6%98%93%E4%B8%BA%E7%94%9FII:%E5%8D%96%E5%87%BA%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B%E4%B8%AD%E7%9A%84%E7%B2%BE%E5%8D%8E/" class="post-title-link" itemprop="url">投资著作品读1：《以交易为生II:卖出的艺术》中的精华</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-20 22:34:00 / 修改时间：22:38:59" itemprop="dateCreated datePublished" datetime="2020-12-20T22:34:00+08:00">2020-12-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%95%E8%B5%84%E8%91%97%E4%BD%9C%E5%93%81%E8%AF%BB/" itemprop="url" rel="index">
                    <span itemprop="name">投资著作品读</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近重读了这本经典的金融投资类书籍，把其中精华部分摘录的下来，除了摘录的部分，第三章内容介绍的交易日志介绍了如何给一笔交易打分也不错，作者让我们更多的关注一笔交易的好坏，而不仅仅是盯住账户盈亏，这样日积月累交易技术才会精进。以下是本书精华部分，介绍了多种卖出的目的与技术。</p>
<h1>第二部分 如何卖出</h1>
<p>卖出策略分为下列三种：</p>
<ol>
<li>止盈卖出</li>
<li>保护性止损卖出</li>
<li>在止盈或止损之间卖出，因为市场状况变化了，我们接下来不再希望持有这只股票</li>
</ol>
<h2 id="第四章-止盈">第四章 止盈</h2>
<ol>
<li>你的止盈价是多少—这只股票可能会涨多少？</li>
<li>股票跌多少你才会相信你的买入决策是错误的，并止损。</li>
<li>这只股票的期望损益比是多少？潜在的收益和风险之间的关系是什么？</li>
</ol>
<p>对波段交易者来说，使用移动平均线和通道组合是设置目标价的好方法。如果要设立长期交易的盈利目标，就需要查看长期的支撑和压力在哪里。</p>
<h3 id="移动平均线卖出">移动平均线卖出</h3>
<p>周线图中，在价值之下买入，把盈利目标设置在价值区，这个方法非常好用。三重过滤网系统要求在周K线做出战略决策，在日K线实施，日线是做战术性买入或卖出的时间框架。</p>
<h3 id="使用通道技术卖出">使用通道技术卖出</h3>
<p>如果使用通道技术给交易设定了盈利目标，但后来你觉得反弹高度会更高一些怎么办？你可能会持有多长时间？尽管价格有时候会反弹得很高，它容易让人放弃先前的决定而持有更长时间，但经验告诉我不要持有头寸时间过久。</p>
<p>如果价格比你设定的初始目标价低一些，你会获利了结吗？当这个问题摆在我面前的时候，我就等价格创新高失败的那天以收盘价卖出，或者在次日开盘后不久卖出。</p>
<h3 id="压力位卖出">压力位卖出</h3>
<p>移动平均线卖出法适用于股票超卖后的反弹，通道卖出法适合短线交易者使用，这些方法可以用于短期波段交易。短期交易的波动幅度相对于长期交易者来说太小，我们曾把长线交易者称为投资者，但世界在变快，每个人又都是交易者。长线交易者的交易周期以月甚至年来衡量，这需要更大的盈利目标。猎鹿的人与猎兔子的人不同，猎鹿的人需要一杆大枪。</p>
<p>支撑和压力区的存在为长线交易者提供了盈利目标。我们把大量交易发生过的地方作为压力或支撑区，这样就很容易知道相对于压力或支撑，价格目前所处的位置。</p>
<p>每开始一次交易，你都应该有两个目标：赚钱和变成更好的交易者。你不一定每次都达到第一个目标，但必须达到第二个目标。如果没有从交易中学到什么，你就是在浪费时间和金钱。</p>
<h2 id="第五章-止损">第五章 止损</h2>
<p>每次交易都应该设定止损。请务必遵循这个简单的规则：在确切地知道止损位置之前，不要交易。入场前你必须做出这个决策，当然你还应该确立一个盈利目标以计算损益比。没有目标的交易无异于赌博。</p>
<h3 id="铁三角止损">铁三角止损</h3>
<p>设立止损的首要目的是避免情势不利时损失超过预期，第二个目的是保护浮盈，第三个目的毫无疑问是控制与资金管理有密切关系的总资金亏损。</p>
<p>风险控制工作的过程分三个步骤：</p>
<ol>
<li>
<p>分析并设定止损位，通过入场价与止损价之间的距离计算每股风险损失值。</p>
<p>假如准备以18美元/每股的价格买入股票，分析后发现如果股价跌破17美元就改变看多观点，所以你决定把保护性止损设在16.89美元。每股风险值是1.11美元，如果加上滑点的话每股风险值会更高一点，但是1.11美元已经是一个合理的估计值了。</p>
</li>
<li>
<p>运用资金管理规则确定单次交易的最大损失额度以及交易者所能承受的风险值。</p>
<p>假设你的交易账户有5万美元，并遵循2%的资金管理规则。这意味着你每次交易的最大风险值是1000美元，这个风险值也比较适中，实际中不少人希望止损小于1%。</p>
</li>
<li>
<p>根据1和2中的数据计算可购入的最大股票数量。</p>
<p>这样就可以计算得出单次交易所能购入的最大股票数量。如果单次交易最大风险值是1000美元，每股允许的风险值是1.11美元，最大的交易股数应该小于900股；另外这1000美元中必须包括交易佣金和滑点。还有一点，没有人规定你必须交易最大可购入的股数，如果你觉得风险仍然太大，可以交易比这个数量更少的股票。如果你对这只18美元的股票抱有很大期望，就应该把止损空间设得大一些，比如在15.89美元，然后每股允许的风险值将会是2.11美元；单次交易的最大损失值不变，因此你最多可购入的股票数量就只有470股了。</p>
</li>
</ol>
<h3 id="市价止损和限价止损">市价止损和限价止损</h3>
<p>市价指令可以保证执行，但不能保证价格；限价指令保证价格但不能保证一定会执行。</p>
<h3 id="硬止损和软止损">硬止损和软止损</h3>
<p>硬止损是下到市场中的止损指令，软止损是交易者牢记的止损价格，只要市场价格达到止损价格，就立即下单。</p>
<h3 id="糟糕的止损位">糟糕的止损位</h3>
<p>关于止损的最糟糕的认识是，只要价格低于最近的最低价就立即止损</p>
<h3 id="止损设在前低上：减少滑点">止损设在前低上：减少滑点</h3>
<p>把止损点设在前期低点上而不是低于前期低点一个Tick的地方。看了很多图表后我发现，很少有股票在价格跌到前低的时候停下脚步，它们往往跌破前低。正常情况下，价格不是到不了前低就是跌破前低，这表明把止损设在低于前低一个Tick的位置上对交易安全没有帮助，所以我开始把止损设在前低的位置上。</p>
<h3 id="尼克止损法">尼克止损法</h3>
<p>寻找大多数人设置止损的价格，然后找出跌破该价格的K线，并把止损设在两个次低价中较低的那个价格之下。这种紧随的设置止损方法非常适合短期波段交易，试图抓住底部是很危险的，而这样一个紧随性止损却会很好地保护账户，这就像告诉市场，要么来打我止损（反正止损不大），要么就给我涨。</p>
<h3 id="使用宽幅止损的时机">使用宽幅止损的时机</h3>
<p>交易周期影响止损大小，较短时间框架内的交易止损必须小，而长周期框架的交易要求止损大一些。短期时间框架内的价格运动先于长期时间框架内的价格运动。</p>
<h3 id="移动止损">移动止损</h3>
<ul>
<li>可以用K线组合的低点作为新的止损点，比如把止损移动到最近三根K线最低价的位置（但决不要和交易方向相反）。</li>
<li>可以使用周期非常短的移动平均线，并把均线值作为追踪止损值。</li>
<li>可以使用枝形灯止损法，市场每次创新高都从最高点起算，以特定的距离向上移动止损，这个距离的计算应基于ATR（真实波幅）。只要股价创新高，就把止损向上移一定距离，这种方式就像从天花板上挂一盏枝形灯（本方法已经在《走进我的交易室》中介绍过）。</li>
<li>抛物线止损。</li>
<li>安全区止损。</li>
<li>回撤比例止损。</li>
<li>时间止损，如果在一定时间内价格没有变化就止损。比如做一笔日内交易，如果股价在10～15分钟内明显没有按照你的预期变化，那么最好了结这次交易；如果做一笔波段交易并预计股价会持续好几个交易日，但是一周过去了股价仍在横盘整理。这表明价格没有确认你的判断，安全的做法是赶紧出局。</li>
</ul>
<h3 id="抛物线止损指标">抛物线止损指标</h3>
<p>今日SAR=前一日SAR+AF×（EP–前一日SAR）</p>
<p>其中，今日SAR=今日止损价；</p>
<p>EP=当前交易中到达过的极点，如果看多，EP就表示近期明显的低点；如果看空，EP就表示近期明显的高点；</p>
<p>AF=加速因子。</p>
<p>交易的第一天加速因子等于0.02，表示你必须把止损设在近期极值的2%处；只要价格创下新高或新低，加速因子就增加0.02，加速因子的最大值是0.2。</p>
<p>抛物线系统在趋势行情中运行很好，但在震荡行情中却频频失灵。另外，不要在计算机自动交易中使用这个系统。</p>
<h3 id="安全区止损">安全区止损</h3>
<p>安全区止损的理念来源于金融市场中的信号和噪音，如果趋势是信号，那么回调就是噪音。</p>
<p>我们可以用多种方法定义趋势，比较简单且直接的方法是用价格与22天EMA的相对位置来定义趋势。在涨势中我们把噪音定义为今日价格中低于前一天低点的部分，这部分与趋势相反；如果是跌势我们把噪音定义为今日价格中高于前一天高点的部分。交易者需要决定测量噪音的回测期的长度，回测期不能太长但必须对交易有实质意义，只需日线图中最近一个月左右的数据就可以了</p>
<p>如果在上涨趋势中把所有噪音部分标出来并汇总，除以噪音发生的总次数，就得出回测期的噪音均值，它反映了当前上升趋势中的平均噪音水平。把止损设得太近容易弄巧成拙，所以要把止损设在远离噪音均值的地方，用噪音均值乘以平均噪音系数（初始值为2，也可用大于2的数值），用昨天最低价减去上面的这个计算结果就得出了止损应该设置的地方。如果今天的最低值比昨天低就不移动止损，这种方法只允许将止损向上移动。</p>
<p>下跌趋势与上涨趋势的规则相反。当22日EMA均线显示目前处于下跌趋势，计算回测期噪音均值并乘以系数，用昨日最高价加上上述数值，就得出今日的止损设置位置。同样，止损只向下移动不向上移动。</p>
<h3 id="波幅减少追踪止损法">波幅减少追踪止损法</h3>
<p>如果市场即将疯狂并大幅移动，我自然愿意留在市场中。我使用通道设置价格目标，通道宽度的正常值是2.7倍标准差。如果我想在价格达到目标价以后使用追踪止损，我会把止损设在1.7倍标准差的地方，只要价格继续沿着正常通道运动我就一直持有，但只要收盘价在1.7倍标准差这个通道内我就离场。通道宽度可以用修改通道参数的方法来修改。</p>
<h3 id="如何决定在价格达到盈利目标时是获利了结还是使用追踪止损？">如何决定在价格达到盈利目标时是获利了结还是使用追踪止损？</h3>
<p>如果价格到达盈利目标并且看到顶背离信号，我就不用追踪止损；只要看到不利的价格运动，比如长上影伴随巨大的成交量，我会在盈利目标位获利了结；如果市场运行良好，并且底部一次比一次高，我就使用追踪止损方法。在价格到达盈利目标后，只有看到足够积极的价格信号我才会使用追踪止损。</p>
<h3 id="盈利目标转换为追踪止损的使用频率是多少？">盈利目标转换为追踪止损的使用频率是多少？</h3>
<p>我在2/3的交易中都使用这种方法，但用得不是很好。有时候刚刚设定了追踪止损，5分钟后就被扫出局。大约有一半时间追踪止损法给我带来比原先更多的利润，大的获益极少，主要来自大行情中。</p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/12/13/2020-12-13%20%E4%B8%80%E4%B8%AAPandas%20MultiIndex%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/2020-12-13%20%E4%B8%80%E4%B8%AAPandas%20MultiIndex%E7%B4%A2%E5%BC%95%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Pandas MultiIndex索引使用问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-12-13 16:54:00 / 修改时间：17:53:59" itemprop="dateCreated datePublished" datetime="2020-12-13T16:54:00+08:00">2020-12-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于MultiIndex的资料并不太多，<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html" target="_blank" rel="noopener">官方文档</a>链接请点这里查看。</p>
<p>最近在使用MultiIndex时遇到的一个问题，先描述一下数据格式。我使用MultiIndex DataFrame来存储股票未来N天的收益率，变量命名为returns，数据样例如下，columns 1d和5d分别表示未来1天和5天的股票收益率，index为MultiIndex，第一级索引为日期，第二级索引为股票代码。</p>
<pre><code>                              1d        5d
2005-01-04 000001.XSHE -0.009202  0.010736
           000002.XSHE  0.036053  0.045541
           000004.XSHE  0.020896  0.068657
           000005.XSHE  0.023474  0.098592
           000006.XSHE  0.014286  0.178571
...                          ...       ...
2020-12-11 688600.XSHG       NaN       NaN
           688777.XSHG       NaN       NaN
           688788.XSHG       NaN       NaN
           688981.XSHG       NaN       NaN
           689009.XSHG       NaN       NaN
</code></pre>
<p>对returns用start=‘2020-01-01’、end='2020-12-11’起止时间做了截断处理，代码片段如下：</p>
<pre><code>returns_index = returns.index.get_level_values(level=0)
returns = returns.loc[(returns_index &gt; pd.to_datetime(start)) &amp; (returns_index &lt; pd.to_datetime(end))]
</code></pre>
<p>这样获取的数据是从2020年开始的，但是使用returns.index.levels[0]发现数据还是从2005年开始的</p>
<pre><code>returns.index.levels[0]
DatetimeIndex(['2005-01-04', '2005-01-05', '2005-01-06', '2005-01-07',
               '2005-01-10', '2005-01-11', '2005-01-12', '2005-01-13',
               '2005-01-14', '2005-01-17',
               ...
               '2020-11-30', '2020-12-01', '2020-12-02', '2020-12-03',
               '2020-12-04', '2020-12-07', '2020-12-08', '2020-12-09',
               '2020-12-10', '2020-12-11'],
              dtype='datetime64[ns]', length=3875, freq=None)
</code></pre>
<p>想了想，应该是由于index索引不可变，这里需要重建MultiIndex DataFrame，需要用到pandas.MultiIndex.remove_unused_levels() 方法先删除掉index里多余的信息，然后再重新创建MultiIndex DataFrame，代码如下：</p>
<pre><code class="language-python">tmp = returns.index.remove_unused_levels()
tmp = returns.index.remove_unused_levels()
returns = pd.DataFrame(returns, tmp)
returns.index.levels[0]
</code></pre>
<pre><code>DatetimeIndex(['2020-01-02', '2020-01-03', '2020-01-06', '2020-01-07',
               '2020-01-08', '2020-01-09', '2020-01-10', '2020-01-13',
               '2020-01-14', '2020-01-15',
               ...
               '2020-11-27', '2020-11-30', '2020-12-01', '2020-12-02',
               '2020-12-03', '2020-12-04', '2020-12-07', '2020-12-08',
               '2020-12-09', '2020-12-10'],
              dtype='datetime64[ns]', length=228, freq=None)
</code></pre>
<p>看输出结果已经获取到了正确的时间范围内的数据。</p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/12/09/2020-12-09%20%E4%B8%80%E4%B8%AAPandas%E7%B4%A2%E5%BC%95%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/09/2020-12-09%20%E4%B8%80%E4%B8%AAPandas%E7%B4%A2%E5%BC%95%E7%94%9F%E6%88%90%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">一个Pandas索引生成的小问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-09 17:13:00" itemprop="dateCreated datePublished" datetime="2020-12-09T17:13:00+08:00">2020-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-10 10:17:16" itemprop="dateModified" datetime="2020-12-10T10:17:16+08:00">2020-12-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天遇到一个Pandas索引生成的问题，需要根据股票日频数据生成1分钟间隔的index，想了3个方法来生成：</p>
<p>方法1: 如果有1分钟bar数据的话可以直接读取数据获取index值，可惜没有哈</p>
<p>方法2: pandas.date_range，这个方法可以生成一个时间序列，设置参数<strong>freq</strong>=‘1min’ ，但是这样生成的结果包含了非交易时间段的数据，运行试了下速度也比较慢。</p>
<p>方法3: 两个list循环，第一个list是日期数据，第二个list是交易时间段的1分钟间隔数据，这个办法虽然笨点但是运行速度还挺快的，具体方法如下：</p>
<pre><code class="language-python">import itertools

import tushare as ts
import pandas as pd

pro = ts.pro_api()
df = ts.pro_bar(ts_code='000001.SZ', adj='hfq', start_date='20200101', end_date='20201209')
df.index = pd.to_datetime(df['trade_date'])
df.sort_index(inplace=True)

times = [d.strftime('%H:%M:%S') for d in
         pd.date_range('09:30:00', '11:30:00', closed='right', freq=('{}min'.format(1)))] + [
            d.strftime('%H:%M:%S') if d.strftime('%H:%M:%S') != '13:00:00' else '11:30:00' for d in
            pd.date_range('13:00:00', '15:00:00', closed='right', freq=('{}min'.format(1)))]

tmp = [str(item[0])[:10] + ' ' + item[1] for item in itertools.product(list(df.index), times)]
min1_index = pd.to_datetime(tmp)
print(min1_index)
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-python">DatetimeIndex(['2020-01-02 09:31:00', '2020-01-02 09:32:00',
               '2020-01-02 09:33:00', '2020-01-02 09:34:00',
               '2020-01-02 09:35:00', '2020-01-02 09:36:00',
               '2020-01-02 09:37:00', '2020-01-02 09:38:00',
               '2020-01-02 09:39:00', '2020-01-02 09:40:00',
               ...
               '2020-12-09 14:51:00', '2020-12-09 14:52:00',
               '2020-12-09 14:53:00', '2020-12-09 14:54:00',
               '2020-12-09 14:55:00', '2020-12-09 14:56:00',
               '2020-12-09 14:57:00', '2020-12-09 14:58:00',
               '2020-12-09 14:59:00', '2020-12-09 15:00:00'],
              dtype='datetime64[ns]', length=54480, freq=None)
</code></pre>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/11/29/2020-11-29%20Quantopian%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A9%E6%95%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9APyfolio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/29/2020-11-29%20Quantopian%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A9%E6%95%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9APyfolio/" class="post-title-link" itemprop="url">Quantopian投资组合和绩效分析工具：Pyfolio</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-29 09:53:00 / 修改时间：16:58:31" itemprop="dateCreated datePublished" datetime="2020-11-29T09:53:00+08:00">2020-11-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">量化交易系统</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="介绍">介绍</h3>
<p>pyfolio是由Quantopian开发的Python库，用于对金融投资组合进行绩效和风险分析。它与Zipline开源回溯测试库配合使用良好。<br>
pyfolio的核心是所谓的“tear sheet ”，它由各种单独的图组成，这些图提供了交易算法性能的全面图像展示。</p>
<h3 id="入门示例">入门示例</h3>
<p>这里以双均线策略来做演示，当20日均线上穿40日均线买入股票，当20日均线下穿40日均线则卖出股票，首先我们通过tushare获取股票历史数据</p>
<pre><code class="language-python">import pandas as pd
import numpy as np
import tushare as ts
import pyfolio as pf

pro = ts.pro_api()
df = ts.pro_bar(ts_code='000001.SZ', adj='hfq', start_date='20150101', end_date='20191231')
df.index = pd.to_datetime(df['trade_date'])
df.sort_index(inplace=True)
</code></pre>
<p>接下来生成策略信号</p>
<pre><code class="language-python">df['ma20'] = df['close'].rolling(20).mean()
df['ma40'] = df['close'].rolling(40).mean()
# 计算20日均线和40日均线的距离
df['diff'] = df['ma20'] - df['ma40']
# 当diff值大于0买入股票，当diff值小于0卖出股票
df['signal'] = np.where(df['diff'] &gt; 0, 1, 0)
df['signal'] = np.where(df['diff'] &lt; 0, 0, df['signal'])
# 计算策略每日收益，这里计算每日收益使用log函数，signal计算由于使用了当天的收盘价，所以需要shift 1天，否则会用到未来数据
df['strategy'] = np.log(df['close'] / df['close'].shift(1)) * df['signal'].shift(1)
# 计算资产收益率
df['equity'] = df['strategy'].cumsum() + 1
</code></pre>
<p>展示资产收益率曲线，这里对股价做了归一化处理以便数据展示，可以看到双均线策略不仅跑赢股价，并且资金曲线回撤相对较小。</p>
<pre><code class="language-python">df['close_norm'] = df['close'] / float(df['close'][0])
df[['close_norm','equity']].plot(figsize=(12,6))
</code></pre>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/1.png" alt=""></p>
<p>上图看到的信息有限，接下来是使用pyfolio工具对投资回报进一步分析，代码如下:</p>
<pre><code class="language-python">pf.create_full_tear_sheet(df['strategy'], benchmark_rets=np.log(df['close'] / df['close'].shift(1)))
</code></pre>
<p>首先是返回汇总信息：</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/2.png" alt=""></p>
<p>介绍常用的几个指标：</p>
<ul>
<li>Annual return：年化回报率</li>
<li>Cumulative returns: 累计收益率，是策略从开始执行到结束的总资产收益率。</li>
<li>Annual volatility：年化波动率</li>
<li>Sharpe ratio：夏普比率，一种非常流行的风险指标。它表示每单位风险（通过标准差衡量）的超额收益（超过无风险利率）。</li>
<li>Sortino ratio: 索提诺比率，Sharpe比率的修改版本，其中标准偏差由下行偏差代替。下行偏差仅衡量该系列的负波动性，严格来说是在称为最低可接受收益的预定水平以下。</li>
<li>Maximum drawdown ：最大跌幅—指示峰和谷之间的最大跌幅（以％表示）</li>
<li>Tail ratio：对daily return的分布选取95分位和5分位，然后相除取绝对值。本质的含义就是赚取的return比亏钱的大多少倍。</li>
<li>Daily value at risk（daily Value-at-Risk ）<br>
每日风险价值-另一个非常流行的风险指标。在这种情况下，这表明在95％的情况下，将头寸（投资组合）再保留1天，损失不会超过2.3％。</li>
</ul>
<p>下图从各个角度对资产回报进行更详细的图表展示</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/3.png" alt=""></p>
<h3 id="参考">参考</h3>
<p><a href="https://quantopian.github.io/pyfolio/" target="_blank" rel="noopener">https://quantopian.github.io/pyfolio/</a><br>
<a href="https://zhuanlan.zhihu.com/p/118108419" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/118108419</a><br>
<a href="https://towardsdatascience.com/the-easiest-way-to-evaluate-the-performance-of-trading-strategies-in-python-4959fd798bb3" target="_blank" rel="noopener">https://towardsdatascience.com/the-easiest-way-to-evaluate-the-performance-of-trading-strategies-in-python-4959fd798bb3</a></p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/11/20/2020-11-20%20Quantopian%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90%E5%88%A9%E5%99%A8_Alphalens/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/2020-11-20%20Quantopian%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90%E5%88%A9%E5%99%A8_Alphalens/" class="post-title-link" itemprop="url">Quantopian单因子分析工具：Alphalens</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 09:22:00" itemprop="dateCreated datePublished" datetime="2020-11-20T09:22:00+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-22 00:54:39" itemprop="dateModified" datetime="2020-11-22T00:54:39+08:00">2020-11-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">量化交易系统</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Quantopian是国外著名的量化交易平台，早期聚宽就是仿照这个网站开发的，算是这类平台的鼻祖了，可惜Quantopian最近刚宣布要停止运营了。Quantopian开发了许多优秀的开源项目，其中比较著名的有zipline、pyfolio和alphalens，zipline是事件驱动的回测引擎，Alphalens与Zipline开源回溯测试库以及Pyfolio配合使用，Pyfolio提供金融投资组合的绩效和风险分析。</p>
<p>Alphalens主要功能是alpha因子的相关性统计数据和图表展示，包括：</p>
<ul>
<li>Returns Analysis</li>
<li>Information Coefficient Analysis</li>
<li>Turnover Analysis</li>
<li>Grouped Analysis</li>
</ul>
<p>下面通过一个例子来了解下Alphalens的主要用法，最重要的函数有两个:</p>
<ul>
<li>
<p>get_clean_factor_and_forward_returns：数据预处理，将因子数据，价格数据和组映射格式化为包含对齐的时间戳和资产代码的MultiIndex索引的DataFrame。返回的数据将被格式化为适合Alphalens函数的格式。因子数据格式是MultiIndex索引，level0是时间，level1是资产代码，数据值只有一列为因子值，数据格式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201121235400.png" alt=""></p>
</li>
<li>
<p>create_full_tear_sheet: 生成全面的单因子分析和评估数据。</p>
</li>
</ul>
<p>通过tushare获取A股股票数据，并将结果处理成get_clean_factor_and_forward_returns参数要求的格式</p>
<pre><code class="language-python">import pandas as pd
import tushare as ts

pro = ts.pro_api()
# 此接口获取的数据为未复权数据，回测建议使用后复权数据，这里为批量获取股票数据做了简化
df = pro.daily(ts_code='000001.SZ,600000.SH', start_date='20200101', end_date='20201231')
df.index = pd.to_datetime(df['trade_date'])
df.index.name = None
df.sort_index(inplace=True)
# MultiIndex，level0为日期，level1为股票代码，assets为get_clean_factor_and_forward_returns所需的因子数据格式
assets = df.set_index([df.index, df['ts_code']], drop=True)
# column为股票代码，index为日期，值为股票收盘价
close = df.pivot_table(index='trade_date',columns='ts_code',values='close')
close.index = pd.to_datetime(close.index)
</code></pre>
<p>生成的assets格式入下图所示，红框为index：</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201122003628.png" alt=""></p>
<p>生成的close格式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201122003811.png" alt=""></p>
<p>接下来使用alphalens工具对数据进行分析，这里我们使用股票涨跌幅(字段名为pct_chg)作为因子数据</p>
<pre><code class="language-python">from alphalens.utils import get_clean_factor_and_forward_returns
from alphalens.tears import create_full_tear_sheet
# 需要将pct_chg做shift处理，否则将使用未来数据
ret = get_clean_factor_and_forward_returns(assets[['pct_chg']].shift(2),close)
create_full_tear_sheet(ret, long_short=False)
</code></pre>
<p>使用默认参数的情况下，ret将包含未来1、5、10日收益率，factor因子值，这里对应pct_chg列，factor_quantile为因子分组结果，默认会将因子分成5组，ret结果如图所示:</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201122004722.png" alt=""></p>
<p>调用create_full_tear_sheet会生成因子分析结果，包含分位数统计信息、收益率信息、分组平均收益率柱状图、所有收益率分布图、单信号组合构建收益率图等，截取部分数据图如下：</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201122005223.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201122005156.png" alt=""></p>
<p>以上就是样例全部内容，可以看到alphalens功能非常丰富，还需要继续深入学习了解。</p>
<h3 id="参考">参考</h3>
<p><a href="http://quantopian.github.io/alphalens/" target="_blank" rel="noopener">http://quantopian.github.io/alphalens/</a></p>
<p><a href="https://www.quantopian.com/posts/alphalens-a-new-tool-for-analyzing-alpha-factors" target="_blank" rel="noopener">https://www.quantopian.com/posts/alphalens-a-new-tool-for-analyzing-alpha-factors</a></p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/11/13/2020-11-13%20pandas-profiling-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/13/2020-11-13%20pandas-profiling-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%A9%E5%99%A8/" class="post-title-link" itemprop="url">pandas-profiling 数据分析利器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-13 16:37:00 / 修改时间：16:37:30" itemprop="dateCreated datePublished" datetime="2020-11-13T16:37:00+08:00">2020-11-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="介绍">介绍</h3>
<p>pandas-profiling可以为DataFrame生成一份报告，在pandas中 df.describe() 是比较基础的探索性数据分析函数，而pandas_profiling则是在DataFrame的基础上扩展，用于快速数据分析。</p>
<p>对于每个column，以下统计信息（与列类型相关）将显示在交互式HTML报告中：</p>
<ol>
<li>类型推断：检测DataFrame中列的类型。</li>
<li>概要：类型，唯一值，缺失值</li>
<li>分位数统计信息，例如最小值，Q1，中位数，Q3，最大值，范围，四分位数范围</li>
<li>描述性统计数据，例如均值，众数，标准偏差，和，中位数绝对偏差，变异系数，峰度，偏度</li>
<li>出现频率高的值</li>
<li>直方图</li>
<li>高度相关变量（Spearman，Pearson和Kendall矩阵）的相关性分析</li>
<li>缺失值：矩阵，计数（count），热图和缺失值树状图</li>
<li>重复行列出出现次数最多的重复行</li>
<li>文本分析：了解文本数据的类别（大写，空格），脚本（拉丁，西里尔字母）和块（ASCII）</li>
</ol>
<h3 id="安装">安装</h3>
<p>使用pip安装</p>
<blockquote>
<p>pip install pandas-profiling</p>
</blockquote>
<p>使用conda安装</p>
<blockquote>
<p>conda install -c anaconda pandas-profiling</p>
</blockquote>
<h3 id="一行代码生成报告">一行代码生成报告</h3>
<p>首先导入测试数据，这里我们使用tushare获取的股票数据来进行测试。</p>
<pre><code class="language-python">import pandas as pd
import tushare as ts
from pandas_profiling import ProfileReport

pro = ts.pro_api()
symbol = '000001.SZ'
df = ts.pro_bar(ts_code=symbol, adj='qfq', start_date='20200101', end_date='20201113')
df.index = pd.to_datetime(df['trade_date'])
df.index.name = None   # 这步不可缺少，否则生成报告时同名列会报错
df.sort_index(inplace=True)
</code></pre>
<p>接下来生成测试报告</p>
<pre><code class="language-python">report = ProfileReport(df.sample(frac=0.05), title='%s 股票分析' % symbol)
report.to_file(output_file='%s.html' % symbol)
</code></pre>
<p>报告汇总信息如下截图</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20201113162700.png" alt=""></p>
<h3 id="大数据问题解决方案">大数据问题解决方案</h3>
<p>当pandas-profiling应用在大数据量的DataFrame上运行速度会非常慢，这时候可以考虑使用以下办法解决。</p>
<h4 id="1-Minimal模式">1. Minimal模式</h4>
<p>在此模式下report会去掉一些耗时的计算操作，生成一份简略的数据分析报告。通过将参数minimal设置为True可以开启此模式。</p>
<pre><code class="language-python">profile = ProfileReport(large_dataset, minimal=True)
profile.to_file(&quot;output.html&quot;)
</code></pre>
<h4 id="2-采样">2. 采样</h4>
<p>采样方式可以有效降低数据量，但缺点是可能漏掉某些数量较小的错误情况。</p>
<pre><code class="language-python">tmp = df.sample(100) # 方法1，随机采样100条数据
tmp = df.sample(frac=0.01)   # 方法2，返回数据的比例，不可以跟上面的数值同时使用
</code></pre>
<h3 id="参考">参考</h3>
<p><a href="https://pandas-profiling.github.io/pandas-profiling/docs/master/rtd/" target="_blank" rel="noopener">https://pandas-profiling.github.io/pandas-profiling/docs/master/rtd/</a></p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/03/01/2020-02-20%20%E8%82%A1%E7%A5%A8%E9%87%8D%E5%A4%A7%E5%88%A9%E5%A5%BD%E5%BC%80%E7%9B%98%E5%B0%81%E6%B6%A8%E5%81%9C%EF%BC%9F%E8%AF%95%E8%AF%95%E8%BF%99%E4%B8%AA%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/01/2020-02-20%20%E8%82%A1%E7%A5%A8%E9%87%8D%E5%A4%A7%E5%88%A9%E5%A5%BD%E5%BC%80%E7%9B%98%E5%B0%81%E6%B6%A8%E5%81%9C%EF%BC%9F%E8%AF%95%E8%AF%95%E8%BF%99%E4%B8%AA%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">股票重大利好开盘封涨停买不到？试试这个办法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-01 01:27:00 / 修改时间：12:18:37" itemprop="dateCreated datePublished" datetime="2020-03-01T01:27:00+08:00">2020-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">量化交易系统</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大家也许有过这种经历，关注的某只股票突发利好消息预判会连续涨停，赶紧打开炒股软件准备下单，发现这只股票已经涨停了，而且是几十万手的大单封死，根本没机会下手，随后几天只能看着股票一个涨停接一个涨停的一路上涨，后悔下手太慢。这种情况还有办法上车吗，散户一般能想到的办法都没戏，但是可以试试下面这种办法，吃不到肉但也许能喝口汤。</p>
<h3 id="ETF套利介绍">ETF套利介绍</h3>
<p>在介绍之前我们先了解下什么是ETF套利？ETF指的是交易型开放式指数基金，是一种在交易所上市交易，并且份额可以变动的一种开放式基金，它的手续与股票是完全一样的。由于一级市场和二级市场同时存在，不可避免会出现价格无法同步的显现，这种情况下就给一些机构跨市场套利提供了条件，而套利交易会让套利机会消失，让两个市场的价格差异得到控制，从而保证一级和二级市场价格的一致性。因为一级市场只能是机构投资者参与，所以我们一般的投资者是没办法进行ETF套利的。</p>
<h3 id="散户该如何操作呢">散户该如何操作呢</h3>
<p>那我们怎么参与涨停股票的交易呢，办法很简单，可以找出持有我们要买入的涨停股的ETF基金，再看看基金持有的股票数量占基金的比重，找持有股票占比大的基金买入。一般基金持仓比较分散，每只股票持有数量从百分之零点几到百分之十几不等，而且优质股票往往被上百只基金同时持有，如何快速找到持有股票的基金和比重呢？</p>
<h3 id="操作实战">操作实战</h3>
<p>以天齐锂业为例，我们从东方财富网上可以找到机构持仓明细 <a href="http://data.eastmoney.com/zlsj/detail/2019-12-31-0-002466.html%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%89%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%9F%BA%E9%87%91%EF%BC%8C%E6%88%91%E4%BB%AC%E9%80%89%E6%8B%A9ETF%E5%9F%BA%E9%87%91%EF%BC%8C%E6%AF%94%E5%A6%82%E6%9C%80%E8%BF%91%E6%AF%94%E8%BE%83%E7%81%AB%E7%9A%84%E5%8D%8E%E5%A4%8F%E4%B8%AD%E8%AF%815G%E9%80%9A%E4%BF%A1%E4%B8%BB%E9%A2%98ETF" target="_blank" rel="noopener">http://data.eastmoney.com/zlsj/detail/2019-12-31-0-002466.html，可以看到有多种类型的基金，我们选择ETF基金，比如最近比较火的华夏中证5G通信主题ETF</a></p>
<p><img src="/uploads/image-20200301015233403.png" alt="image-20200301015233403"></p>
<p>进入到该基金的页面 <a href="http://fundact.eastmoney.com/fundinfo/515050.html?fund=515050%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E8%AF%A5%E5%9F%BA%E9%87%91%E6%8C%81%E6%9C%89%E7%9A%84%E5%89%8D%E5%8D%81%E5%A4%A7%E8%82%A1%E7%A5%A8%EF%BC%8C%E7%AC%AC%E4%B8%80%E5%90%8D%E5%B0%B1%E6%98%AF%E4%B8%AD%E5%85%B4%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%8D%A0%E6%AF%949.90%25" target="_blank" rel="noopener">http://fundact.eastmoney.com/fundinfo/515050.html?fund=515050，可以查看该基金持有的前十大股票，第一名就是中兴通信，占比9.90%</a></p>
<p><img src="/uploads/image-20200301015411242.png" alt="image-20200301015411242"></p>
<p>了解以上的数据源之后，我们可以写个python程序快速的找到某只股票的基金持仓及占比情况，源码如下：</p>
<pre><code class="language-python">import requests
import execjs
from bs4 import BeautifulSoup

REQUEST_HEADER = {
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'}


def get_stock_fundlist(symbol, date='2019-12-31'):
    &quot;&quot;&quot;
        查询股票被持有的基金及持仓占比
    :param symbol: 股票代码，例如: SZ000001
    :param date: 报告日期，例如：2019-12-31，2019-03-31
    :return:
    &quot;&quot;&quot;
    stock_url = 'http://data.eastmoney.com/zlsj/detail.aspx?type=ajax&amp;sr=-1&amp;p=1&amp;ps=1000&amp;stat=0&amp;code=%s&amp;date=%s&amp;rt=52763434'
    fund_url = 'http://fund.eastmoney.com/f10/FundArchivesDatas.aspx?type=jjcc&amp;code=%s&amp;topline=15'

    web_source = requests.get(stock_url % (symbol[2:], date), headers=REQUEST_HEADER, timeout=5)
    js_obj = execjs.compile(web_source.content.decode('gbk'))
    results = js_obj.eval('jsname')
    if 'data' not in results:
        return
    etf_list = [record['SHCode'] for record in results['data'] if record['SHCode'].startswith('5')]
    results = {}
    for code in etf_list[:]:
        web_source = requests.get(fund_url % code, headers=REQUEST_HEADER, timeout=5)
        html_source = web_source.content.decode()
        html_source = html_source.split(&quot;\&quot;&quot;)[1]
        soup = BeautifulSoup(html_source, 'lxml')
        items = soup.select(&quot;.tzxq&quot;)[0].select('tr')
        for item in items[1:]:
            if symbol[2:] not in item.text:
                continue
            fields = item.select('td')
            record = [field.text.strip() for field in fields if
                      field.text.strip() != '' and '变动' not in field.text]
            results[code] = record[3][:-1]
            break
    return sorted(results.items(), key=lambda kv: kv[1], reverse=True)


if __name__ == '__main__':
    print(get_stock_fundlist('SZ000063', '2019-12-31'))

</code></pre>
<p>执行代码输出结果如下：</p>
<pre><code class="language-shell">[('515050', '9.90'), ('570007', '6.87'), ('519668', '6.52'), ('501062', '5.37'), ('550002', '5.13'), ('515000', '5.10'), ('570006', '5.08'), ('501028', '4.81'), ('502013', '4.33'), ('501015', '4.26'), ('550015', '4.22'), ('515580', '4.19'), ('501026', '4.19'), ('512970', '3.94'), ('519929', '3.69'), ('515200', '3.32'), ('550001', '3.06'), ('550008', '3.05'), ('501081', '3.05'), ('550009', '2.99'), ('512220', '2.95'), ('501076', '2.26'), ('519013', '2.09'), ('515880', '10.75'), ('510080', '1.60'), ('590007', '0.99'), ('519676', '0.71')]

</code></pre>
<p>可以看到所有基金中持有中兴通讯最多份额的基金是515050，该基金持仓里中兴通讯占基金的比例为9.9%，意味着中兴通讯每涨停一天对基金会有0.99%的贡献。</p>
<p>当然，这个办法有很多的局限性，比如基金持有的股票多数是优质股，这种机会比较难碰到，而且指数型基金往往持仓非常分散，也不适用这种办法。如果基金中其他股票下跌也会造成基金下跌。</p>
<p>515050 5GETF这种主题基金比较适合这种个股利好涨停的，遇到针对整个行业的利好消息，这种主题型的ETF往往同时持有多只股票出现大幅上涨，2月24日当天，515050 这只基金除了中兴通讯涨停外，信维通信和沪电股份也出现了涨停，这三只股票基金持仓占比高达17.18%，如果之后出现了连续涨停的走势，对基金影响将非常明显。</p>
<p>除了515050 5GETF还有其他几个比较适合的，比如159995 芯片ETF，515700 新能车，512760 半导体50等，可以都关注着，没准哪天掉下来个利好呢。</p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/02/16/2020-02-16%20%E4%BD%BF%E7%94%A8Python%E6%8A%93%E5%8F%96%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%B5%84%E9%87%91%E6%B5%81%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/16/2020-02-16%20%E4%BD%BF%E7%94%A8Python%E6%8A%93%E5%8F%96%E5%90%8C%E8%8A%B1%E9%A1%BA%E8%B5%84%E9%87%91%E6%B5%81%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">使用Python抓取同花顺资金流数据</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-16 01:14:00 / 修改时间：10:21:03" itemprop="dateCreated datePublished" datetime="2020-02-16T01:14:00+08:00">2020-02-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">量化交易系统</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天我们通过一个例子来介绍python爬取数据的一般步骤，用到的工具包括python的经典模块requests和BeautifulSoup，另外结合刚学习的任务流工具TaskFlow来完成代码开发。</p>
<p>我们先来看一下要爬取的数据，网址是http://data.10jqka.com.cn/funds/gnzjl/，通过chrome的开发者工具分析我们可以比较容易找到后台数据加载网址为</p>
<blockquote>
<p><a href="http://data.10jqka.com.cn/funds/gnzjl/field/tradezdf/order/desc/page/%7Bpage_num%7D/ajax/1/free/1/" target="_blank" rel="noopener">http://data.10jqka.com.cn/funds/gnzjl/field/tradezdf/order/desc/page/{page_num}/ajax/1/free/1/</a></p>
</blockquote>
<p>其中page_num的位置为要查询第几页的数据，在网页上看到概念一共有6页数据，所以page_num取值为1-6</p>
<p><img src="/uploads/WechatIMG109.png" alt="WechatIMG109"></p>
<p>这里有个小技巧，可以先点击图片左上角的清空按钮，把已经加载的网址先清理掉，然后在原始网页上点第二页，就能看到图片左下角新加载的网址，点开右边“Preview” 看到资金流数据相关的内容，就能确定这个网址是用来加载数据的。</p>
<p>在chrome浏览器中输入 <a href="http://data.10jqka.com.cn/funds/gnzjl/field/tradezdf/order/desc/page/1/ajax/1/free/1/%EF%BC%8C%E5%B9%B6%E6%89%93%E5%BC%80chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%9C%A8%E7%BD%91%E9%A1%B5%E6%BA%90%E7%A0%81%E4%B8%AD%E6%89%BE%E5%88%B0%E6%95%B0%E6%8D%AE%E6%89%80%E5%9C%A8table%E6%A0%87%E7%AD%BE%E4%B8%BA" target="_blank" rel="noopener">http://data.10jqka.com.cn/funds/gnzjl/field/tradezdf/order/desc/page/1/ajax/1/free/1/，并打开chrome开发者工具，在网页源码中找到数据所在table标签为</a></p>
<pre><code class="language-html">&lt;table class=&quot;m-table J-ajax-table&quot;&gt;
	...
&lt;/table&gt;
</code></pre>
<p>抓取数据的完整源码如下</p>
<pre><code class="language-python">import time

import requests
from bs4 import BeautifulSoup
from taskflow import engines
from taskflow.patterns import linear_flow
from taskflow.task import Task

REQUEST_HEADER = {
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.97 Safari/537.36'}


class MoneyFlowDownload(Task):
    &quot;&quot;&quot;
    下载资金流数据
    数据源地址：http://data.10jqka.com.cn/funds/gnzjl/

    &quot;&quot;&quot;
    BASE_URl = {
        &quot;concept&quot;: 'http://data.10jqka.com.cn/funds/gnzjl/field/tradezdf/order/desc/page/%s/ajax/1/free/1/',
    }

    def execute(self, bizdate, *args, **kwargs):

        for name, base_url in self.BASE_URl.items():
            # 爬取数据的存储路径
            dt_path = '/data/%s_%s.csv' % (bizdate, name)

            with open(dt_path, &quot;a+&quot;) as f:
                # 记录数据文件的当前位置
                pos = f.tell()
                f.seek(0)
                lines = f.readlines()
                # 读取文件中的全部数据并将第一列存储下来作为去重依据，防止爬虫意外中断后重启程序时，重复写入相同
                crawled_list = list(map(lambda line: line.split(&quot;,&quot;)[0], lines))
                f.seek(pos)
                # 循环500次，从第一页开始爬取数据，当页面没有数据时终端退出循环
                for i in range(1, 500):
                    print(&quot;start crawl %s, %s&quot; % (name, base_url % i))
                    web_source = requests.get(base_url % i, headers=REQUEST_HEADER)
                    soup = BeautifulSoup(web_source.content.decode(&quot;gbk&quot;), 'lxml')
                    table = soup.select('.J-ajax-table')[0]
                    tbody = table.select('tbody tr')
                    # 当tbody为空时，则说明当前页已经没有数据了，此时终止循环
                    if len(tbody) == 0:
                        break
                    for tr in tbody:
                        fields = tr.select('td')
                        # 将每行记录第一列去掉，第一列为序号，没有存储必要
                        record = [field.text.strip() for field in fields[1:]]
                        # 如果记录还没有写入文件中，则执行写入操作，否则跳过这行写入
                        if record[0] not in crawled_list:
                            f.writelines([','.join(record) + '\n'])
                    # 同花顺网站有反爬虫的机制，爬取速度过快很可能被封
                    time.sleep(1)


if __name__ == '__main__':
    bizdate = '20200214'
    tasks = [
        MoneyFlowDownload('moneyflow data download')
    ]
    flow = linear_flow.Flow('ths data download').add(*tasks)
    e = engines.load(flow, store={'bizdate': bizdate})
    e.run()

</code></pre>
<p>执行程序后，在dt_path位置已经存储了概念的资金流数据，文件名为20200214_concept.csv，内容大致如下：</p>
<pre><code class="language-shell">钛白粉,1008.88,6.29%,7.68,6.21,1.47,7,金浦钛业,10.04%,2.96
磷化工,916.833,2.42%,37.53,34.78,2.75,28,六国化工,9.97%,4.08
光刻胶,1435.68,2.40%,43.51,44.31,-0.80,20,晶瑞股份,10.01%,42.99
</code></pre>
<p>此时就完成了同花顺概念分类的资金流数据的爬取，之后可以每天定时启动任务抓取数据进行分析。</p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2020/02/08/2020-02-08%20OpenStack%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6TaskFlow%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/08/2020-02-08%20OpenStack%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6TaskFlow%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">OpenStack公共组件TaskFlow介绍</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-08 23:13:00" itemprop="dateCreated datePublished" datetime="2020-02-08T23:13:00+08:00">2020-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-09 16:19:57" itemprop="dateModified" datetime="2020-02-09T16:19:57+08:00">2020-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TaskFlow 是一个以高度可用，易于理解和声明试方式来执行[作业，任务，流程]的库，可与OpenStack和其他项目一起使用。</p>
<h1>基本概念</h1>
<p>taskflow库在oslo项目中是一个实现比较复杂的项目，要弄清楚其实现原理，首先需要对其中的相关概念有所了解。所以，本文首先总结了taskflow中常用的一些基本概念，这些概念主要包括如下几个：</p>
<h2 id="Atom">Atom</h2>
<p>Atom类是taskflow的最小单位，taskflow中其他类，包括Task等都需要继承这个类。一个Atom对象是一个命名对象，通过操作输入数据以执行一些促进整个流程发展的动作，或者产生一个处理结果等。它是一个抽象类，提供了两个抽象方法：execute()用于执行一个动作，revert()用于根据execute()执行结果和失败信息还原到任务执行之前的状态；除此之外，还分别为这两个方法提供了pre_execute()/post_execute()、pre_revert()/post_revert()方法用于定义在执行execute或revert操作前后执行的操作。</p>
<h2 id="Task">Task</h2>
<p>Task类是一个拥有执行和回滚操作的最小工作单元，表示一个任务流中的某一个任务。它是一个继承自Atom类的表示一个任务的父类，开发者可以执行定义一个继承自Task类的任务类，并重写execute()和revert()方法分别表示执行和回滚的操作。</p>
<p><img src="https://docs.openstack.org/taskflow/latest/_images/tasks.png" alt="Task outline."></p>
<h4 id="Task的两种类型">Task的两种类型:</h4>
<ul>
<li>Task: 对于继承和创建自己的子类很有用。</li>
<li>FunctorTask: 对于将现有function包装到任务对象中很有用，但是不能应用在engine中</li>
</ul>
<h2 id="Retry">Retry</h2>
<p>Retry类也是一个继承自Atom的抽象类，它主要定义了当有错误发生时，如何进行重试操作。其也包含也不同的类型，将会在接下来的部分进行详细介绍。继承重试的子类必须提供on_failure()函数来对故障进行处理。</p>
<h4 id="为避免重复创建常见的重试模式，提供了以下常见的重试子类：">为避免重复创建常见的重试模式，提供了以下常见的重试子类：</h4>
<ul>
<li>
<p>AlwaysRevert: 始终还原subflow.</p>
</li>
<li>
<p>AlwaysRevertAll: 始终还原整个flow</p>
</li>
<li>
<p>Times: 对subflow重试指定次数</p>
</li>
<li>
<p>ForEach: 允许在每次发生故障时为subflow提供不同的值（使其有可能通过更改subflow输入来解决故障）</p>
</li>
<li>
<p>ParameterizedForEach: 和ForEach类似，但是从存储中获取值.</p>
<p><img src="https://docs.openstack.org/taskflow/latest/_images/inheritance-18bf8f4505f8b8f3ecd1914b3ff8965622138a35.png" alt="Inheritance diagram of taskflow.atom, taskflow.task, taskflow.retry.Retry, taskflow.retry.AlwaysRevert, taskflow.retry.AlwaysRevertAll, taskflow.retry.Times, taskflow.retry.ForEach, taskflow.retry.ParameterizedForEach"></p>
</li>
</ul>
<p>关于重试的策略，taskflow通过一个枚举类型的Decision定义了三种策略：</p>
<ul>
<li>REVERT：仅回滚失败Flow对象周围或关联的子流Flow对象。该策略在回滚子流Flow对象之前，会首先咨询其父Atom对象以确定父Atom对象是否使用不同的重试策略。该策略允许安全的嵌套具有不同重试策略的Flow对象。如果父Atom对象中没有定义重试策略，则默认只回滚关联子流Flow对象中的Atom对象。当然，你可以通过defer_revert参数改变默认行为，当其设置为True，表示REVERT策略将继承父Atom的策略，如果父Atom对象没有重试策略，则它也将被回滚。</li>
<li>REVERT_ALL：不管失败Flow对象的父Atom对象的策略如何，都将回滚整个流程。</li>
<li>RETRY：重试该失败的Flow/Task对象。</li>
</ul>
<h2 id="Flow">Flow</h2>
<p>Flow类是一个用来关联所有相关Task类，并规定这些Task类的执行和回滚顺序的抽象类。而oslo中为Flow提供了三种实现方式：graph_flow表示图流，linear_flow表示线性流，unordered_flow表示无序流。关于这三种类型的流实现会在之后进行详细分析。</p>
<p><img src="https://docs.openstack.org/taskflow/latest/_images/inheritance-d843124115abb8d565dc2aea882f408d4b57072b.png" alt="Inheritance diagram of taskflow.flow, taskflow.patterns.linear_flow, taskflow.patterns.unordered_flow, taskflow.patterns.graph_flow"></p>
<ul>
<li>linear_flow：线性流，该类型的Flow对象将按照Task/Flow加入的顺序来依次执行，按照加入的倒序依次回滚。</li>
<li>graph_flow：图流，该类型的Flow对象会按照给加入的Task/Flow显示指定的依赖关系或通过其间的provides/requires属性隐含的依赖关系执行和回滚。</li>
<li>unordered_flow：无序流，该类型的Flow对象所加入的Task/Flow会按照任意顺序执行或回滚。</li>
</ul>
<p>要弄清楚这三种类型的Flow对象，首先需要了解oslo定义的Flow基类的构成。在oslo定义的Flow基类中，主要包含以下几个重要的属性和方法：</p>
<ul>
<li>name：表示初始化Flow对象时，为其指定的名称，并不能唯一表示一个Flow对象。</li>
<li>retry：表示与该Flow对象关联的重试控制器。</li>
<li>provides：表示该Flow对象提供的一组符号名称。</li>
<li>requires：表示该Flow对象所需要的一组&quot;unsatisfied&quot;符号名称。</li>
<li>add(*items)：该方法用于为该Flow对象添加一个或一组Task/Flow对象。</li>
<li>iter_links()：迭代Flow对象的子节点之间的依赖关系链接。例如在迭代一个三元组(A, B, meta)时，就是迭代一个从子节点A（一个Atom对象或一个Subflow）指向子节点B（一个Atom对象或一个Subflow）的链接；换句话说，也就代表了子流B依赖于子流A，或者子流B需要子流A；而meta代表了这个依赖关系链接的元数据，是一个字典。</li>
<li>iter_nodes()：迭代Flow对象中的所有节点。例如在迭代一个二元组（A, meta）时，A（一个Atom对象或一个Subflow）是当前Flow对象的子流或子任务；meta同样代表了这个链接的元数据，是一个字典。</li>
</ul>
<h2 id="Engine">Engine</h2>
<p>Engine类是一个表示真正运行Atom对象的抽象类，它的实现类主要用于载入（load）一个Flow对象，然后驱动这个Flow对象的Task对象开始运行。Engine的实现也有多种不同的形式，这也会在接下来的部分进行详细介绍。</p>
<p>taskflow在具体实现Task/Flow管理时，首先定义了一个Engine抽象类，所有实现都需要继承这个抽象类。这个抽象类定义了如下重要属性和方法：</p>
<ul>
<li>notifier：一个通知对象，它会分发与Engine对象中包含的Flow对象相关的事件通知。</li>
<li>atom_notifier：一个通知对象，它会分发与Engine对象中包含的Atom对象相关的事件通知。</li>
<li>options：相关数据结构传递给Engine对象的选项。</li>
<li>storage：Engine对象的存储单元。</li>
<li>statistics：Engine对象收集的运行时统计数据字典。当Engine没有运行时，这个值为空；在Engine正在运行时或已经运行之前，它可能会存储一些对正在运行或运行完成时有用的或包含信息的键值对。</li>
<li>compile()：该方法可以将Engine对象中包含的Flow对象编译成Engine对象内部表示形式。这个内部表示形式就是Engine对象实际用于运行的流的形式。</li>
<li>reset()：将Engine对象重置为PENDING状态。如果一个Flow以FAILURE、SUCCESS、REVERTED状态结束运行（即调用Engine对象的run()方法之后），或由于某种状态使得其处于某种中间状态，此时可以调用reset()方法进行重置，然后进行重试操作。</li>
<li>prepare()：在Engine对象编译完所有包含的Flow对象之后，且在Flow运行之前执行该方法，为流程的执行进行一些准备操作。</li>
<li>validate()：在Engine对象编译完所有包含的Flow对象之后，且在Flow运行之前执行该方法，为流程的执行进行一些验证操作。</li>
<li>run()：运行Engine对象中的Flow流程。</li>
<li>suspend()：该方法尝试暂停Engine对象。如果一个Engine对象正在执行某个Atom对象，则执行该方法会将这个Atom对象之后的所有正要运行的工作都暂停，并将这个Engine对象的状态变为暂停状态，以便之后进行恢复操作。</li>
</ul>
<p>taskflow在具体实现Engine时，都需要给上述属性和方法重新赋值或进行覆写操作，以实现一个完整的管理流程Flow/Task对象的Engine类。在taskflow中，目前实现了三种策略的Engine类，而在这三种策略中，有两种是面向行为的action_egine类：SerialActionEngine、ParallelActionEngine；另一种是面向多进程的worker_base类：WorkerBaseActionEngine。这三种类型的Engine类的异同点如下所示：</p>
<ul>
<li>SerialActionEngine：这是一个以串行方式运行任务的Engine类，也就是说所有的任务都会在调用engine.run()方法的线程中顺序执行。</li>
<li>ParallelActionEngine：这是一个以并行方式运行任务的Engine类，即可以在多个线程中运行Engine对象中的任务。在这种策略中，taskflow定义了对应的多个ParallelThreadTaskExecutor创建运行任务的线程</li>
<li>WorkerBaseActionEngine：这是一个可以将任务调度到不同worker（即进程）中执行的Engine类。</li>
</ul>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuqi365.com/2019/12/11/2019-12-11%20cython%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpg">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Python量化交易实战">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/11/2019-12-11%20cython%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">cython使用入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-11 10:20:00" itemprop="dateCreated datePublished" datetime="2019-12-11T10:20:00+08:00">2019-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-09 01:11:25" itemprop="dateModified" datetime="2020-02-09T01:11:25+08:00">2020-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index">
                    <span itemprop="name">量化交易系统</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近工作上遇到一个问题，某券商提供的文件单接口需要用其提供的c语言工具调用，由于我们的交易框架是python开发的，所以需要用到cython来调用c开发的工具包，学习了cython的官方入门教程顺便记录如下。</p>
<h3 id="cython介绍">cython介绍</h3>
<p>Cython是针对Python编程语言和扩展的Cython编程语言（基于Pyrex）的优化静态编译器。<br>
它使为Python编写C扩展与Python本身一样容易。</p>
<h3 id="编写样例代码">编写样例代码</h3>
<p>首先，创建一个后缀为pyx的文件cython_example.pyx，编写cython函数</p>
<pre><code class="language-python">def say_hello_to(name):
    print(&quot;Hello %s!&quot; % name)
</code></pre>
<p>然后编写相应的编译脚本文件:</p>
<pre><code class="language-python">from distutils.core import setup
from Cython.Build import cythonize

setup(name='Hello world app',
      ext_modules=cythonize(&quot;cython_example.pyx&quot;))
</code></pre>
<h3 id="编译代码">编译代码</h3>
<pre><code class="language-shell">python setup.py build_ext --inplace
</code></pre>
<p>报如下错误：</p>
<pre><code class="language-shell">running build_ext
building cython_example extension
error: Unable to find vcvarsall.bat
</code></pre>
<h4 id="Which-Microsoft-Visual-C-compiler-to-use-with-a-specific-Python-version">Which Microsoft Visual C++ compiler to use with a specific Python version ?</h4>
<table>
<thead>
<tr>
<th>visual c++</th>
<th>python</th>
</tr>
</thead>
<tbody>
<tr>
<td>14.x</td>
<td>3.5,3.6,3.7,3.8</td>
</tr>
<tr>
<td>10.0</td>
<td>3.3,3.4</td>
</tr>
<tr>
<td>9.0</td>
<td>2.6, 2.7, 3.0, 3.1, 3.2</td>
</tr>
</tbody>
</table>
<p>我使用的是python3.6，所以下载 Visual C++ 2015 Build Tools（包含Visual C++ 14.0）</p>
<p>下载地址：</p>
<p><a href="http://go.microsoft.com/fwlink/?LinkId=691126&amp;fixForIE=.exe" target="_blank" rel="noopener">http://go.microsoft.com/fwlink/?LinkId=691126&amp;fixForIE=.exe</a>.</p>
<p>安装之后重新执行编译命令输出如下最后两行说明编译通过:</p>
<pre><code class="language-shell">Generating code
Finished generating code
</code></pre>
<p>会在当前目录下生成build目录和cython_example.cp36-win32.pyd</p>
<p>接下来做个测试，<a href="http://xn--test-k84fuit3ty95h.py" target="_blank" rel="noopener">编写一个test.py</a>，内容如下</p>
<pre><code class="language-python">import cython_example

cython_example.say_hello_to('eryk')
</code></pre>
<p>执行命令后输出如下结果说明调用cython函数成功了</p>
<pre><code class="language-shell">Hello eryk!
</code></pre>
<h3 id="参考">参考</h3>
<p><a href="http://docs.cython.org/en/latest/src/quickstart/build.html" target="_blank" rel="noopener">http://docs.cython.org/en/latest/src/quickstart/build.html</a></p>
<p><a href="https://wiki.python.org/moin/WindowsCompilers" target="_blank" rel="noopener">https://wiki.python.org/moin/WindowsCompilers</a></p>
<p><a href="https://stackoverflow.com/questions/29846087/microsoft-visual-c-14-0-is-required-unable-to-find-vcvarsall-bat" target="_blank" rel="noopener">https://stackoverflow.com/questions/29846087/microsoft-visual-c-14-0-is-required-unable-to-find-vcvarsall-bat</a></p>
<p>我的微信公众号：pyquant</p>
<p><img src="https://raw.githubusercontent.com/eryk/blog_img/master/20190424095328.jpg" alt=""></p>

      

<img src="https://eryk.github.io/uploads/gzh.jpg"  alt="Python量化交易实战" /><center>欢迎您扫码订阅我的微信公众号: pyquant</center>
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/uploads/avatar.jpg">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/eryk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eryk" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.weibo.com/eryk86" title="Weibo → https:&#x2F;&#x2F;www.weibo.com&#x2F;eryk86" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Author</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
